/*

+-------------------------------------+
| Caskeda Data Markup Language (CDML) |
+-----------+-------------------------+
| Extension | `.cdml`                 |
| Type Code | `TEXT`                  |
| Mime-Type | `application/cdml`      |
| Website   | https://longor.net/cdml |
+-----------+-------------------------+

CDML is a data/file format for storing and moving complex data,
while it keeping friendly for both humans and computers to read.

- CDML is *always* encoded as UTF-8 plaintext with unix line-separators.
	- Note: UTF-8 without Byte-Order-Mark.

- CDML is a partial (!) superset of JSON, so any parser for it
	should also be able to read JSON files.

- The inherent structure of the 'stream' section can be used to
	store/process streaming data, such as log files and progressive assets.

- As defined by the grammar, any parser will need to be able to look-ahead
	at least 3 codepoints, without backtracking or stream seeking.

---

Any valid parser for CDML must:

- Have callbacks for type-tags, raw strings and expressions.
- Let the consumer of the data ignore the casing of keys.
- Have a flag to ignore processing of the 'raw' section.
- Provide a way to set a string-interning table to reduce memory waste.
- Allow setting a maximum nesting depth to prevent overflows.

- Return the following data:
	- The header section of a CDML file as is.
	- The stream section of a CDML file as a (lazy?) list of nodes.
	- The raw section of a CDML file (if asked to) as buffer of bytes.

- Provide the following metadata:
	- The total amount of parsed nodes in the file.
	- The greatest depth encountered in the hierarchy.
	- The amount of bytes & lines read, excluding raw data.

- Never return the shebang (if there is one) or any and all line-comments.

- Immediately stop parsing if a invalid UTF-8 codepoint is encountered.

---

This grammmar file uses a slightly specialized dialect of EBNF.

*******************************************************************************/

#ENTRYPOINT
file: shebang? header stream raw
	shebang: '#' (.*?) \n
	header:  struct_dict
	stream:  (node_wrap [;\n])*
	raw:     ';;;' (.*?) \n .*

#BETWEEN_TOKENS:
	whitespace: \s*
	comments: '//' (.*?) \n

/******************************************************************************/

// wrapper for generic node structure
node_wrap: node_type? node_data node_combi

// additional node data
node_type: '#' string_bare
node_combi: node_pair?
	node_pair: '&' node_data

// nodes can have names
node_key:
	| string_bare
	| string_quote1
	| string_quote2

// the actual node/item
node_data:
	| value
	| struct
	| expression

/******************************************************************************/

value:
	| value_undefined
	| value_nothing
	| value_boolean
	| value_numword
	| value_number
	| value_string

struct:
	| struct_dict
	| struct_list
	| struct_path
	| struct_obj
	| struct_graph
	| struct_table

expression: '(' expression_op expression_arg_pos* expression_arg_key* ')'
	expression_op: .*? \s
	expression_arg_pos: node_wrap
	expression_arg_key: string_bare '=' (node_data node_combi)

/******************************************************************************/

value_undefined: '_'

value_nothing: 'null'

value_boolean:
	| 'true'
	| 'false'

value_numword:
	| 'pi'
	| 'euler'
	| 'sqrt2'
	| 'infinity'
	| 'infinite'
	| 'NaN'

value_number: num_sign? (value_numword | num_int num_dec? num_pow? num_unit?)
	num_sign: '+' | '-'
	num_int: digits
	num_dec: '.' digits10
	num_pow: [eE^] sign? digits
	num_unit: #IF_PRE (digits16)
		#THEN: '#' string_bare
		#ELSE: string_bare

digits:
	| digits2
	| digits8
	| digits10
	| digits16

// concrete digits definition
digits2:  '0b'  [_01]+         // base 2:  dual|binary
digits8:  '0o'  [_01234567]+   // base 8:  octal
digits10: '0d'? [_0123456789]+ // base 10: decimal
digits16: '0x'  [_0123456789ABCDEFabcdef]+ // base 16: hexadecimal

value_string:
	| string_bare
	| string_quote1
	| string_quote2
	| string_embed

// concrete strings definition
string_bare: \l (\l|[_.-])*
string_quote1: "'" (.-"'")* "'"
string_quote2: '"' (.-'"')* '"'
string_embed: string_bare? (string_embed_q1 | string_embed_q3)
	string_embed_q1: "`" (.-"`")* "`"
	string_embed_q3: "```" (.-"```")* "```"

/******************************************************************************/

struct_dict: '{' dict_item* '}'
	dict_item: node_key ':' node_wrap [,\n]

struct_list: '[' list_item ']'
	list_item: node_wrap [,\n]

struct_path: '/' path_component struct_path?
	path_component: path_virtual? node_wrap
	path_virtual: ':'

struct_obj: '<' obj_attributes? obj_children? (';' obj_attributes)? '>'
	obj_attributes: obj_attribute*
		obj_attribute: node_key ':' node_wrap [,\n]
	obj_children: ';' (node_wrap [,\n])*

struct_table: '<[' table_head table_meta ';' table_rows ']>'
	table_head: node_key+
	table_meta: struct_dict?
	table_rows: (table_row ';')*
	table_row:  node_wrap

struct_graph: '<{' graph_head ';' graph_nodes ';' graph_edges '}>'
	graph_head:  graph_attr*
		graph_attr: node_key ':' node_wrap [,\n]
	// define nodes
	graph_nodes: graph_node*
		graph_node: node_key graph_node_value? [,\n]
			graph_node_value: ':' node_wrap
	// define edges
	graph_edges: graph_edge*
		graph_edge: node_key? (node_key node_key) graph_edge_vals? [,\n]
			// define edge value-positions
			graph_edge_vals: ':'\
				('+=' node_wrap)?\
				('-=' node_wrap)?\
				('=' node_wrap)?

/******************************************************************************/